<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Markdown + LaTeX Editor</title>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
body { font-family: Arial, sans-serif; margin:0; height:100vh; display:flex; }
#editor { width:50%; height:100%; border-right:2px solid #ccc; box-sizing:border-box; display:flex; flex-direction:column; padding:10px;}
#editor textarea { flex:1; width:100%; font-size:16px; padding:10px; resize:vertical; box-sizing:border-box; }
#preview { width:50%; height:100%; padding:20px; overflow-y:auto; background-color:#f9f9f9;}
h1 {font-size:2em;margin:0.5em 0;} h2 {font-size:1.7em;margin:0.5em 0;} h3 {font-size:1.4em;margin:0.5em 0;} h4 {font-size:1.2em;margin:0.5em 0;}
strong{font-weight:bold;} em{font-style:italic;} u{text-decoration:underline;} del{text-decoration:line-through;}
ul{margin:0.5em 0 0.5em 1.5em; padding:0;} ol{margin:0.5em 0 0.5em 1.5em; padding:0;} li{margin:0.2em 0;}
button{margin-top:5px; padding:5px 10px; font-size:14px; cursor:pointer;}
</style>
</head>
<body>

<div id="editor">
<textarea placeholder="Eingabe…"></textarea>
<button onclick="copyToClipboard()">Script kopieren</button>
</div>

<div id="preview"></div>

<script>
// Hilfs-Array, um Inline-Mathe-Ausdrücke zu speichern
const inlineMaths = [];

// Markdown-Konvertierung
function convertMarkdown(text){
    // 1. Inline-Mathe extrahieren und durch Platzhalter ersetzen, um Konflikte zu vermeiden
    let processedText = text.replace(/\$(.+?)\$/g, function(match, content) {
        const token = '%%INLINEMATH'+inlineMaths.length+'%%';
        // MathJax verwendet `\(...\)` für Inline-Mathe
        inlineMaths.push('\\('+content.trim()+'\\)');
        return token;
    });

    // 2. Normale Markdown-Formatierung anwenden
    processedText = processedText.replace(/^#### (.+)$/gm,'<h4>$1</h4>');
    processedText = processedText.replace(/^### (.+)$/gm,'<h3>$1</h3>');
    processedText = processedText.replace(/^## (.+)$/gm,'<h2>$1</h2>');
    processedText = processedText.replace(/^# (.+)$/gm,'<h1>$1</h1>');

    // Stil-Formatierung: Reihenfolge beibehalten
    processedText = processedText.replace(/__(.+?)__/g,'<u>$1</u>'); // Unterstrichen
    processedText = processedText.replace(/\*(.+?)\*/g,'<strong>$1</strong>'); // Fett (Strong)
    processedText = processedText.replace(/_(.+?)_/g,'<em>$1</em>'); // Kursiv (Em)
    processedText = processedText.replace(/~(.+?)~/g,'<del>$1</del>'); // Durchgestrichen

    // 3. Inline-Mathe-Platzhalter wieder einfügen
    processedText = processedText.replace(/%%INLINEMATH(\d+)%%/g, function(match, index) {
        return inlineMaths[parseInt(index)];
    });

    return processedText;
}

// Haupt-Rendering-Funktion (Logik für Zeilenumbruch beibehalten)
function renderPreview(){
    let input = document.getElementById('inputText').value;

    // Arrays für Platzhalter zurücksetzen
    inlineMaths.length = 0;

    // Block-Mathe extrahieren und Platzhalter setzen
    const blockMaths = [];
    input = input.replace(/\$\$([\s\S]*?)\$\$/g, function(match, content){
        const token = '%%BLOCKMATH'+blockMaths.length+'%%';
        blockMaths.push(content);
        return token;
    });

    const lines = input.split('\n');
    let html = '';
    let inUL = false;
    let inOL = false;
    let inParagraph = false; // Verfolgt, ob wir uns in einem `<p>`-Block befinden

    const closeParagraph = () => {
        if (inParagraph) {
            html += '</p>';
            inParagraph = false;
        }
    };
    const openParagraph = () => {
        if (!inParagraph) {
            html += '<p>';
            inParagraph = true;
        }
    };
    const closeLists = () => {
        if (inUL) { html += '</ul>'; inUL = false; }
        if (inOL) { html += '</ol>'; inOL = false; }
    };

    // Verarbeiten der Zeilen
    lines.forEach(line=>{
        const trimmed = line.trim();

        // 1. Überschrift-Erkennung
        if(/^#+ /.test(line.trim())){
            closeLists();
            closeParagraph();
            html += convertMarkdown(line);
            return;
        }

        // 2. Block-Mathe-Erkennung
        const blockMatch = trimmed.match(/%%BLOCKMATH(\d+)%%/);
        if(blockMatch){
            closeLists();
            closeParagraph();
            // MathJax-Block-Mathe-Format: \[...\]
            html+='<div>\\['+blockMaths[parseInt(blockMatch[1])]+ '\\]</div>';
            return;
        }

        // 3. Listen-Erkennung (Ungeordnet)
        if(/^[-*] /.test(trimmed)){
            closeParagraph(); // Schließt Absatz, bevor die Liste beginnt
            if(inOL){html+='</ol>'; inOL=false;}
            if(!inUL){html+='<ul>'; inUL=true;}
            html+='<li>'+convertMarkdown(trimmed.replace(/^[-*] /,''))+'</li>';
            return;
        }

        // 4. Listen-Erkennung (Nummeriert)
        const numMatch = trimmed.match(/^(\d+)\. (.+)/);
        if(numMatch){
            closeParagraph(); // Schließt Absatz, bevor die Liste beginnt
            if(inUL){html+='</ul>'; inUL=false;}
            const num = parseInt(numMatch[1]);
            const content = numMatch[2];
            if(!inOL){html+=`<ol start="${num}">`; inOL=true;}
            html+='<li>'+convertMarkdown(content)+'</li>';
            return;
        }

        // 5. Ende der Liste
        if(inUL || inOL){
            if(!(/^[-*] /.test(trimmed) || /^(\d+)\. /.test(trimmed))){
                closeLists();
                // Nach dem Ende einer Liste einen neuen Absatz beginnen
                openParagraph();
            }
        }

        // 6. Normale Textzeilen (Hier wird der Zeilenumbruch erzwungen)
        if (!inUL && !inOL) {
            if (line.trim() === '' && line.length === 0) {
                // Nur eine leere Zeile, um den Abstand zu erzwingen
                openParagraph();
                html += '<br>';
            } else if (line.trim() !== '' || line.length > 0) {
                // Normale Textzeile - Konvertieren und <br> anhängen
                openParagraph();
                html += convertMarkdown(line) + '<br>';
            }
        }
    });

    // Schließen am Ende des Dokuments
    closeLists();
    closeParagraph();

    // Aufräumen von leeren <p>-Tags
    html = html.replace(/<p><\/p>/g, '');

    document.getElementById('preview').innerHTML = html;
    MathJax.typeset(); // MathJax rendert sowohl Inline- als auch Block-Mathe
}

// KORRIGIERTE Copy-Button Funktion
function copyToClipboard(){
    // Holt den Wert (den Text) aus dem Textarea-Element
    const text = document.getElementById("inputText").value;
    
    // Verwendet die Clipboard API, um den Text zu schreiben
    navigator.clipboard.writeText(text).then(() => {
        alert("Text des Editors in Zwischenablage kopiert!");
    }).catch(err => {
        console.error('Kopieren fehlgeschlagen: ', err);
        alert("Kopieren fehlgeschlagen. Bitte versuchen Sie es manuell.");
    });
}

// Initialisierung und Event-Listener
document.getElementById('inputText').addEventListener('input',renderPreview);
renderPreview();
</script>


</body>
</html>
