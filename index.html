<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>LaTeX Converter</title>
<style>
body { font-family: Arial, sans-serif; margin:0; height:100vh; display:flex; flex-direction: column; }

/* Hauptinhaltsbereich (Editor und Output) */
.main-content {
    display: flex;
    flex: 1;
    width: 100%;
}
#editor-container, #output-container {
    width: 50%;
    height: 100%;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
}
#editor-container {
    border-right: 2px solid #ccc;
}
#mdInput, #latexOutput {
    flex: 1;
    width: 100%;
    font-size: 15px;
    padding: 10px;
    box-sizing: border-box;
    resize: none;
    font-family: monospace;
}
#latexOutput {
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    overflow-y: scroll;
    white-space: pre-wrap;
}

/* Button-Styling */
button {
    margin-bottom: 10px;
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    transition: background-color 0.2s;
}
button:hover {
    background-color: #0056b3;
}
</style>
</head>
<body>

<div class="main-content">
    <div id="editor-container">
        <textarea id="mdInput" placeholder="Markdown hier eingeben…"></textarea>
    </div>

    <div id="output-container">
        <button id="copyBtn">LaTeX-Code kopieren</button>
        <textarea id="latexOutput" readonly></textarea>
    </div>
</div>

<script>
// -----------------------------------------------------------
// HILFSFUNKTIONEN
// -----------------------------------------------------------

// Leere Zeilen und Zeilenumbrüche sollen \\ bekommen,
// aber NICHT nach Block-Math ($$ ... $$)
function isBlockMathLine(line) {
    return line.trim().startsWith("$$") && line.trim().endsWith("$$");
}

// Escape-LaTeX-Sonderzeichen
function escapeLatex(text) {
    const replacements = {
        "\\": "\\textbackslash{}",
        "{": "\\{",
        "}": "\\}",
        "&": "\\&",
        "%": "\\%",
        "#": "\\#",
        "_": "\\_", 
        "^": "\\textasciicircum{}",
        "~": "\\textasciitilde{}",
        "'": "\\textquotesingle{}"
    };
    return text.replace(/([\\{}&%#_^~'])/g, m => replacements[m] || m);
}

// Inline Markdown-Stile
function applyInlineStyles(text) {
    text = text.replace(/__(.+?)__/g, '%%START_U%%$1%%END_U%%');
    text = text.replace(/_(?!_)(.+?)_(?!_)/g, '%%START_I%%$1%%END_I%%');

    text = escapeLatex(text);

    text = text.replace(/%%START_U%%(.+?)%%END_U%%/g, "\\underline{$1}");
    text = text.replace(/%%START_I%%(.+?)%%END_I%%/g, "\\textit{$1}");

    text = text.replace(/(?<!\*)\*(?!\*)([^*]+)(?<!\*)\*(?!\*)/g, "\\textbf{$1}"); 
    text = text.replace(/`([^`]+)`/g, "\\texttt{$1}");

    return text;
}

// Prime-Ersetzung (Mathemodus)
function replacePrimes(mathContent) {
    mathContent = mathContent.replace(/['’]{3}/g, '^{\\prime\\prime\\prime}');
    mathContent = mathContent.replace(/['’]{2}/g, '^{\\prime\\prime}');
    mathContent = mathContent.replace(/['’]/g, '^{\\prime}');
    return mathContent;
}

// Mathe erkennen und verarbeiten
function processTextWithMath(text) {
    const parts = text.split(/(\$[^\$]+\$)/g);
    let processedText = '';
    
    for (const part of parts) {
        if (part.startsWith('$') && part.endsWith('$') && part.length > 1) {
            let mathContent = part.slice(1, -1); 
            mathContent = replacePrimes(mathContent); 
            processedText += '$' + mathContent + '$';
        } else {
            processedText += applyInlineStyles(part);
        }
    }
    return processedText;
}

// -----------------------------------------------------------
// HAUPTKONVERTER
// -----------------------------------------------------------
function convertMarkdown(md) {
    const lines = md.split("\n");
    let out = [];
    let inItemize = false;
    let inEnumerate = false;
    let paragraph = [];

    function flushParagraph() {
        if (paragraph.length > 0) {
            const joinedText = paragraph.join(" ").trim();
            if (joinedText.length > 0) { 
                out.push(joinedText);
            }
            paragraph = [];
        }
    }
    
    const closeLists = () => {
        if (inItemize) { out.push("\\end{itemize}"); inItemize = false; }
        if (inEnumerate) { out.push("\\end{enumerate}"); inEnumerate = false; }
    };

    for (let line of lines) {
        const trimmedLine = line.trim();

        // Block-Mathe $$...$$
        if (trimmedLine.startsWith('$$') && trimmedLine.endsWith('$$')) {
            flushParagraph();
            closeLists();
            let mathContent = trimmedLine.substring(2, trimmedLine.length - 2).trim();
            mathContent = replacePrimes(mathContent); 
            out.push('$$ ' + mathContent + ' $$');
            continue;
        }

        // Überschriften
        if (/^#{1,4}\s/.test(trimmedLine)) {
            flushParagraph();
            closeLists();
            let match = trimmedLine.match(/^(#+)/);
            let level = match ? match[1].length : 0; 
            let text = trimmedLine.replace(/^#+\s*/, "");
            text = processTextWithMath(text);
            if (level === 1) out.push("\\section{" + text + "}");
            if (level === 2) out.push("\\subsection{" + text + "}");
            if (level === 3) out.push("\\subsubsection{" + text + "}");
            if (level === 4) out.push("\\paragraph{" + text + "}");
            continue;
        }

        // Ungeordnete Liste
        if (/^\s*[*+-]\s+/.test(line)) {
            flushParagraph();
            if (inEnumerate) closeLists();
            if (!inItemize) {
                inItemize = true;
                out.push("\\begin{itemize}");
            }
            let item = processTextWithMath(line.replace(/^\s*[*+-]\s+/, ""));
            out.push("\\item " + item);
            continue;
        }

        // Geordnete Liste
        if (/^\s*\d+\.\s+/.test(line)) {
            flushParagraph();
            if (inItemize) closeLists();
            if (!inEnumerate) {
                inEnumerate = true;
                out.push("\\begin{enumerate}");
            }
            let item = processTextWithMath(line.replace(/^\s*\d+\.\s+/, ""));
            out.push("\\item " + item);
            continue;
        }

        // Leere Zeile
        if (trimmedLine === "") {
            flushParagraph();
            closeLists();
            out.push(""); 
            continue;
        }

        // Normaler Text
        if (!inItemize && !inEnumerate) {
            line = processTextWithMath(line);
            if (line.trim().length > 0) {
                paragraph.push(line);
            }
        }
    }

    flushParagraph();
    closeLists();

    // -------------------------------------------------------
    // NEUE LOGIK: Jede Zeile bekommt \\ , außer nach $$...$$
    // -------------------------------------------------------
    let finalOut = [];

    for (let i = 0; i < out.length; i++) {
        const line = out[i];

        if (line.trim() === "") {
            finalOut.push("\\\\");
            continue;
        }

        finalOut.push(line);

        if (!isBlockMathLine(line)) {
            finalOut.push("\\\\");
        }
    }

    // Letzte doppelte Backslash entfernen
    while (finalOut[finalOut.length - 1] === "\\\\") finalOut.pop();

    return finalOut.join("\n");
}

// -----------------------------------------------------------
// EVENTS
// -----------------------------------------------------------
document.getElementById("mdInput").addEventListener("input", () => {
    document.getElementById("latexOutput").value = convertMarkdown(
        document.getElementById("mdInput").value
    );
});

document.addEventListener("DOMContentLoaded", () => {
    document.getElementById("latexOutput").value = convertMarkdown(
        document.getElementById("mdInput").value
    );
});

document.getElementById("copyBtn").addEventListener("click", () => {
    const outputField = document.getElementById("latexOutput");
    navigator.clipboard.writeText(outputField.value).then(() => {
        document.getElementById("copyBtn").textContent = "Kopiert!";
        setTimeout(() => {
            document.getElementById("copyBtn").textContent = "LaTeX-Code kopieren";
        }, 1200);
    });
});
</script>

</body>
</html>
